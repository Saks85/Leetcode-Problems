1. Problem Understanding

We need to:
- Start with an array [l, l+1, ..., r].
- In one operation, choose two numbers a and b and replace them with: ⌊𝑎/4⌋,⌊𝑏/4⌋

Goal: reduce all numbers to zero using the minimum number of operations.
Since l and r can be very large  simulating the process directly is impossible. We must mathematically precompute the number of "operation units" needed.

2. Observation: Numbers fall into power-of-4 groups

Every number behaves based on how many times you must divide it by 4 to reach 0:

Range of numbers	Example numbers	# of operations needed per number

[1,3]	1
[4,15]	4 → 1 → 0, 8 → 2 → 0, etc.	2
[16,63]	16 → 4 → 1 → 0	3
[64,255]	...	4

These boundaries are powers of 4: 1,4,16,64,...

This lets us group numbers efficiently rather than iterate over them individually.

3. The getOperations(n) function

getOperations(n) computes the total "operation-units" for all numbers from 1 to n.

Logic inside:

Start with the block [1, 3], each number needs 1 operation-unit.

Next block [4, 15], each number needs 2 operation-units.

Continue doubling block size by factor of 4.

Formula for each block:

res
+
=
(
blockEnd
−
blockStart
+
1
)
×
ops
res+=(blockEnd−blockStart+1)×ops
4. Using prefix logic for query [l, r]

For a query 
[
𝑙
,
𝑟
]
[l,r]:

operationsNeeded
=
𝑔
𝑒
𝑡
𝑂
𝑝
𝑒
𝑟
𝑎
𝑡
𝑖
𝑜
𝑛
𝑠
(
𝑟
)
−
𝑔
𝑒
𝑡
𝑂
𝑝
𝑒
𝑟
𝑎
𝑡
𝑖
𝑜
𝑛
𝑠
(
𝑙
−
1
)
operationsNeeded=getOperations(r)−getOperations(l−1)

Each actual operation affects two numbers, so the final answer is:

operationsNeeded
+
1
2
2
operationsNeeded+1
	​


+1 ensures rounding up when the total count is odd.

5. Time Complexity

Each call to getOperations runs in O(log₄(n)) because block ranges grow by ×4 each time.

For each query, total cost is O(log n) (very efficient, even for 
10
9
10
9
).

Example Walkthrough

Input:

queries = [[1, 3], [4, 15]]


Step 1 – Query [1,3]:

getOperations(3) = 3 (because 1,2,3 each need 1 operation-unit).

getOperations(0) = 0.

Difference = 3 → (3 + 1) / 2 = 2.

Step 2 – Query [4,15]:

getOperations(15) = 3 (for 1-3) + 24 (for 4-15) = 27.

getOperations(3) = 3.

Difference = 24 → (24 + 1) / 2 = 12.5 → 12.

Final total = 2 + 12 = 14

Final Thoughts

This solution works because:

It groups numbers into ranges determined by powers of 4.

Uses a prefix sum idea with getOperations.

Answers each query in O(log n) instead of iterating through [l, r].

This is the most efficient and scalable approach for the problem.
